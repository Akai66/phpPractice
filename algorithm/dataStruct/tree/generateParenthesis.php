<?php
/**
 * Created by PhpStorm.
 * User: liukai
 * Date: 20/3/12
 * Time: 18:25
 */

//题目描述
//题目描述：给定 n 对括号，请写一个函数以将其生成新的括号组合，并返回所有组合结果。

//样例：

//给定 n = 3, 可生成的组合如下: "((()))", "(()())", "(())()", "()(())", "()()()"


//想一想这种生成括号的规则，其实隐含了一条信息：那就是始终左括号的数量要大于或等于右括号的数量。也就是说，剩余的左括号的数量要始终小于等于右括号。左括号只要有，就可以打印；而只有当剩余的右括号数量比左括号大时，才能打印右括号。为了方便理解，我现在假设n = 2，那么根据刚才我说的隐含信息，逻辑应该是这样的：

//1. 肯定要先取一个左括号，此时左括号剩余的数量变为1，右括号剩余数量还是2

//2. 第二位取左括号也行，取右括号也行。如果取左括号，那么此时右括号剩余数量为2，左括号剩余数量为0，长成了这个样子"(("；如果取右括号，左右剩余数量都是1，长成这个样子"()"

//3. 第三位，如果剩余左括号没了，就只能跟进右括号了，连续两个，最终变成"(())"；而如果现在是"()"的，那么要先左后右，最终变成"()()".

//发现，每一步都有两种选择：左或者右，当然不一定都可行，如果可行，那么往后继续，不可行，终止。

//这是什么，二叉树,相当于二叉树的先序遍历(深度优先遍历),根据上述隐含的信息作为条件,实际就是作为判断父节点是否存在左右节点的判断条件,
//递归调用就是遇到递归结束的条件时,就会不断往上一层回退,path就会回到上一层path的状态

function generateParenthesis($n){
    if($n <= 0){
        return false;
    }
    $result = array();
    generate($n,$n,'',$result);
    return $result;
}

function generate($left,$right,$path,&$result){
    if($left == 0 && $right == 0){
        //左右括号全部使用完,说明已经组合成一组有效括号,即为递归结束的条件
        $result[] = $path;
    }
    if($left > 0){
        //左括号剩余数大于0,说明左节点存在
        generate($left-1,$right,$path.'(',$result);
    }
    if($right > $left){
        //右括号剩余数大于左括号剩余数,说明右节点存在
        generate($left,$right-1,$path.')',$result);
    }
}

var_dump(generateParenthesis(3));

